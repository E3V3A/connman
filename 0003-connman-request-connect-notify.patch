diff -ubNr connman-1.13/src/agent.c connman-1.13.a/src/agent.c
--- connman-1.13/src/agent.c	2013-02-01 18:10:00.000000000 +1000
+++ connman-1.13.a/src/agent.c	2013-04-19 14:51:50.460286809 +1000
@@ -28,10 +28,10 @@
 #include <string.h>
 
 #include <gdbus.h>
+#include "connman.h"
 #include <connman/agent.h>
 #include <connman/setting.h>
 
-#include "connman.h"
 
 static DBusConnection *connection = NULL;
 static guint agent_watch = 0;
@@ -133,6 +133,10 @@
 	struct connman_agent *queue_data = user_data;
 	DBusMessage *reply;
 	int err;
+    DBusMessageIter iter;
+    char *key;
+    const char *error = NULL;
+    int type;
 
 	DBG("waiting for %p received %p", agent_request, queue_data);
 
@@ -143,6 +147,7 @@
 	}
 
 	reply = dbus_pending_call_steal_reply(call);
+
 	dbus_pending_call_unref(call);
 	queue_data->call = NULL;
 
@@ -177,7 +182,7 @@
 	struct connman_agent_driver *driver;
 	int err;
 
-	if (user_context == NULL || callback == NULL)
+	if (/*user_context == NULL ||*/ callback == NULL)
 		return -EBADMSG;
 
 	queue_data = g_new0(struct connman_agent, 1);
@@ -187,12 +192,14 @@
 	driver = get_driver();
 	DBG("driver %p", driver);
 
+  if (user_context != NULL) {
 	if (driver != NULL && driver->context_ref != NULL) {
 		queue_data->user_context = driver->context_ref(user_context);
 		queue_data->driver = driver;
-	} else
+      } else {
 		queue_data->user_context = user_context;
-
+      }
+  }
 	queue_data->msg = dbus_message_ref(msg);
 	queue_data->timeout = timeout;
 	queue_data->callback = callback;
@@ -277,6 +284,8 @@
 	agent_sender = g_strdup(sender);
 	agent_path = g_strdup(path);
 
+//    setTryit(0);
+
 	agent_watch = g_dbus_add_disconnect_watch(connection, sender,
 						agent_disconnect, NULL, NULL);
 
diff -ubNr connman-1.13/src/agent-connman.c connman-1.13.a/src/agent-connman.c
--- connman-1.13/src/agent-connman.c	2012-12-23 07:52:47.000000000 +1000
+++ connman-1.13.a/src/agent-connman.c	2013-04-19 14:51:50.456286808 +1000
@@ -625,3 +625,102 @@
 
 	return -EINPROGRESS;
 }
+
+
+struct request_connect_reply_data {
+	struct connman_service *service;
+	request_connect_cb_t callback;
+	void *user_data;
+};
+
+static void request_connect_cb(/*connman_bool_t authentication_done,*/
+                              const char *error,void *user_data)
+{
+// handle reply or timeout here
+
+}
+
+static void request_connect_reply(DBusMessage *reply, void *user_data)
+{
+    DBusMessageIter iter;
+    char *key;
+    int type;
+
+    struct request_connect_reply_data *connect_reply_data = user_data;
+    const char *error = NULL;
+
+    dbus_message_iter_init(reply, &iter);
+    if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
+        error = dbus_message_get_error_name(reply);
+        if (g_strcmp0(error, "net.connman.Agent.Error.Canceled") == 0) {
+            setTryit(0);
+        }
+    }
+    dbus_message_iter_init(reply, &iter);
+    dbus_message_iter_get_basic(&iter, &key);
+
+    DBG(" request_connect_reply <<<<<<<<<<<<<<<<<<<<<<<<<<<<< %s", key);
+      
+		if (g_str_equal(key, "Clear")) {
+      setTryit(0);
+		} else if (g_str_equal(key, "Suppress")) {
+      setTryit(2);
+    }
+
+	g_free(connect_reply_data);
+
+}
+
+int __connman_agent_request_connection(void *user_data)
+{
+
+//    int trythis = (int)user_data;
+    DBG(" __connman_agent_request_connection <<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
+    
+    request_connect_cb_t callback = request_connect_cb;
+    DBusMessage *message;
+    struct request_connect_reply_data *connect_reply_data;
+    const char *agent_sender, *agent_path;
+    int err;
+
+    connman_agent_get_info(&agent_sender, &agent_path);
+    if (agent_path == NULL) {
+        return -ESRCH;
+    }
+
+    message = dbus_message_new_method_call(agent_sender, agent_path,
+                                           CONNMAN_AGENT_INTERFACE,
+                                           "RequestConnect");
+
+    if (message == NULL) {
+        return -ENOMEM;
+    }
+
+    struct connman_service *def_service;
+    def_service = __connman_service_get_default();
+
+    connect_reply_data = g_try_new0(struct request_connect_reply_data, 1);
+    if (connect_reply_data == NULL) {
+        dbus_message_unref(message);
+        return -ENOMEM;
+    }
+
+    connect_reply_data->service = def_service;
+    connect_reply_data->callback = callback;
+    connect_reply_data->user_data =  user_data;
+// TODO is autoconnect - do not send
+
+    err = connman_agent_queue_message(def_service, message,
+                                      (150 * 1000), //timeout
+                                      request_connect_reply, connect_reply_data);
+
+    if (err < 0 && err != -EBUSY) {
+        DBG("Eerror %d sending connect request", err);
+        dbus_message_unref(message);
+        g_free(connect_reply_data);
+        return err;
+    }
+
+    dbus_message_unref(message);
+    return -EINPROGRESS;
+}
diff -ubNr connman-1.13/src/connman.h connman-1.13.a/src/connman.h
--- connman-1.13/src/connman.h	2013-04-09 10:38:59.000000000 +1000
+++ connman-1.13.a/src/connman.h	2013-04-19 14:51:50.460286809 +1000
@@ -94,6 +94,9 @@
 typedef void (* browser_authentication_cb_t) (struct connman_service *service,
 				connman_bool_t authentication_done,
 				const char *error, void *user_data);
+typedef void (* request_connect_cb_t) (/*struct connman_service *service,*/
+				/*connman_bool_t authentication_done,*/
+				const char *error, void *user_data);
 int __connman_agent_request_passphrase_input(struct connman_service *service,
 				authentication_cb_t callback, void *user_data);
 int __connman_agent_request_login_input(struct connman_service *service,
@@ -101,6 +104,10 @@
 int __connman_agent_request_browser(struct connman_service *service,
 				browser_authentication_cb_t callback,
 				const char *url, void *user_data);
+int __connman_agent_request_connection( /*struct connman_service *service,
+        authentication_cb_t callback, */void *user_data);
+
+void  setTryit(int i);
 
 #include <connman/log.h>
 
diff -ubNr connman-1.13/src/dnsproxy.c connman-1.13.a/src/dnsproxy.c
--- connman-1.13/src/dnsproxy.c	2013-04-09 10:38:59.000000000 +1000
+++ connman-1.13.a/src/dnsproxy.c	2013-04-19 15:01:17.800286735 +1000
@@ -3061,6 +3061,8 @@
 				&ifdata->tcp6_listener_watch);
 }
 
+int tryit = 0;
+
 static gboolean udp_listener_event(GIOChannel *channel, GIOCondition condition,
 				struct listener_data *ifdata, int family,
 				guint *listener_watch)
@@ -3103,6 +3105,29 @@
 	if (err < 0 || (g_slist_length(server_list) == 0)) {
 		send_response(sk, buf, len, client_addr,
 				*client_addr_len, IPPROTO_UDP);
+//  error no connection.
+    gboolean ok = FALSE;
+    int len = strlen(query);
+    if (len > 4) {
+        const char *lastFive = &query[len - 5];
+        if (strcmp("arpa.", lastFive) == 0) {
+            ok == FALSE;
+        } else {
+            ok = TRUE;
+        }
+    }
+    if (ok) {
+        setTryit(1);
+        tryit = 1;
+          // tell agent about it
+    DBG("DNS Error OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO");
+        if (__connman_agent_request_connection((void*)tryit) == -ESRCH) {
+        }
+    }
+//    int tryitonce = 1;
+//    setTryit(1);
+  //        if (__connman_agent_request_connection((void*)tryitonce) == -ESRCH) {
+   //     }
 		return TRUE;
 	}
 
@@ -3540,3 +3565,11 @@
 
 	g_hash_table_destroy(partial_tcp_req_table);
 }
+
+void setTryit(int i)
+{
+
+    DBG("setTryit %d", i);
+    tryit = i;
+}
+
